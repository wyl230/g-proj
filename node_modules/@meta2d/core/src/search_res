输入关键词，空格分隔:
['anchor', 'curve', 'line']
./core.js 672     Meta2d.prototype.drawLine = function (lineName) {

./core.js 673         lineName && lockedError(this.store);

./core.js 674         this.canvas.drawingLineName = lineName;

./core.js 701                     case 0: return [4 /*yield*/, this.canvas.finishDrawline(end)];

./core.js 721     Meta2d.prototype.updateLineType = function (pen, lineName) {

./core.js 722         if (!pen || pen.name != 'line' || !lineName || !this.canvas[lineName]) {

./core.js 725         pen.lineName = lineName;

./core.js 734         this.canvas[lineName](this.store, pen, to);

./core.js 735         if (pen.lineName === 'curve') {

./core.js 2040         var lines = [];

./core.js 2042             var lineId = _a.lineId;

./core.js 2043             var line = _this.store.pens[lineId];

./core.js 2044             if (!line) {

./core.js 2050                     lines.push(line);

./core.js 2054                     getToAnchor(line).connectTo === node.id && lines.push(line);

./core.js 2058                     getFromAnchor(line).connectTo === node.id && lines.push(line);

./core.js 2062         return lines;

./core.js 2077             var lines = this.getLines(pen, 'out');

./core.js 2080             lines.forEach(function (line) {

./core.js 2082                 var lineNextNode = _this.nextNode(line);

./core.js 2089                     for (var lineNextNode_1 = __values(lineNextNode), lineNextNode_1_1 = lineNextNode_1.next(); !lineNextNode_1_1.done; lineNextNode_1_1 = lineNextNode_1.next()) {

./core.js 2090                         var node = lineNextNode_1_1.value;

./core.js 2097                         if (lineNextNode_1_1 && !lineNextNode_1_1.done && (_a = lineNextNode_1.return)) _a.call(lineNextNode_1);

./core.js 2118             var lines = this.getLines(pen, 'in');

./core.js 2121             lines.forEach(function (line) {

./core.js 2123                 var linePreNode = _this.previousNode(line);

./core.js 2130                     for (var linePreNode_1 = __values(linePreNode), linePreNode_1_1 = linePreNode_1.next(); !linePreNode_1_1.done; linePreNode_1_1 = linePreNode_1.next()) {

./core.js 2131                         var node = linePreNode_1_1.value;

./core.js 2138                         if (linePreNode_1_1 && !linePreNode_1_1.done && (_a = linePreNode_1.return)) _a.call(linePreNode_1);

./core.js 2161             var lineId = _a.lineId, anchor = _a.anchor;

./core.js 2162             var fromAnchor = (_b = pen.anchors) === null || _b === void 0 ? void 0 : _b.filter(function (_anchor) { return _anchor.id === anchor; })[0];

./core.js 2163             var line = _this.findOne(lineId);

./core.js 2164             if (line.anchors[0].connectTo == pen.id) {

./core.js 2166                 var connectTo = line.anchors[line.anchors.length - 1].connectTo;

./core.js 2169                     var connectedLine_1 = (_c = _next.connectedLines) === null || _c === void 0 ? void 0 : _c.filter(function (item) { return item.lineId === line.id; })[0];

./core.js 2170                     var penAnchor = _next.anchors.filter(function (_anchor) { return _anchor.id === connectedLine_1.anchor; })[0];

./core.js 2174                         line: line,

./core.js 2186      * @param anchor 待添加锚点

./core.js 2189     Meta2d.prototype.addAnchor = function (pen, anchor, index) {

./core.js 2193         if (!pen.anchors) {

./core.js 2194             pen.anchors = [];

./core.js 2201                 index = pen.anchors.length + 1 + index;

./core.js 2203             if (index > pen.anchors.length) {

./core.js 2204                 index = pen.anchors.length;

./core.js 2209             if ((index == 0 && pen.anchors[0].connectTo) ||

./core.js 2210                 (index == pen.anchors.length && pen.anchors[index - 1].connectTo)) {

./core.js 2215         var _anchor = null;

./core.js 2217         if (anchor.x <= 1 && anchor.x >= 0 && anchor.y <= 1 && anchor.y >= 0) {

./core.js 2220                 id: anchor.id || s8(),

./core.js 2223                     pen.calculative.worldRect.width * anchor.x,

./core.js 2225                     pen.calculative.worldRect.height * anchor.y,

./core.js 2232             _anchor = {

./core.js 2235                 x: anchor.x,

./core.js 2236                 y: anchor.y,

./core.js 2242                 id: anchor.id || s8(),

./core.js 2244                 x: anchor.x,

./core.js 2245                 y: anchor.y,

./core.js 2249                     rotatePoint(anchor, -pen.rotate, pen.calculative.worldRect.center);

./core.js 2251                 _anchor = {

./core.js 2254                     x: (anchor.x - pen.calculative.worldRect.x) /

./core.js 2256                     y: (anchor.y - pen.calculative.worldRect.y) /

./core.js 2264             pen.anchors.splice(index, 0, _anchor);

./core.js 2272             pen.anchors.push(_anchor);

./core.js 2300         var line = {

./core.js 2302             lineName: 'line',

./core.js 2303             lineWidth: 1,

./core.js 2304             name: 'line',

./core.js 2309             anchors: [

./core.js 2322         this.addPens([line]);

./core.js 2323         connectLine(from, fromAnchor, line, line.calculative.worldAnchors[0]);

./core.js 2324         connectLine(to, toAnchor, line, line.calculative.worldAnchors[1]);

./core.js 2325         line.calculative.active = false;

./core.js 2326         this.canvas.updateLines(line);

./core.js 2329         this.canvas.initLineRect(line);

./core.js 2333         return line;

./core.js 2339      * @param anchor 是否产生默认的锚点

./core.js 2342     Meta2d.prototype.toComponent = function (pens, showChild, anchor) {

./core.js 2353         if (anchor) {

./core.js 2354             parent.anchors = [

./core.js 2459             globalStore.anchors = {};

./options.js 10     lineHeight: 1.5,

./options.js 12     textBaseline: 'middle',

./options.js 16     anchorColor: '#278DF8',

./options.js 18     anchorRadius: 4,

./options.js 19     anchorBackground: '#fff',

./options.js 31     drawingLineName: 'curve',

./options.js 34     autoPolyline: true,

./data.js 47 export var defaultDrawLineFns = ['curve', 'polyline', 'line'];

./data.js 50     'lineWidth',

./data.js 51     'lineCap',

./data.js 52     'lineJoin',

./data.js 55     'lineGradientFromColor',

./data.js 56     'lineGradientToColor',

./data.js 57     'lineGradientAngle',

./data.js 74     'textBaseline',

./data.js 75     'lineHeight',

./data.js 81     'lineDash',

./canvas/canvas.js 92 import { curve, mind, getLineLength, getLineRect, pointInLine, simplify, smoothLine, lineSegment, getLineR, lineInRect, } from '../diagrams';

./canvas/canvas.js 93 import { polyline, translatePolylineAnchor } from '../diagrams/line/polyline';

./canvas/canvas.js 134         this.curve = curve;

./canvas/canvas.js 135         this.polyline = polyline;

./canvas/canvas.js 137         this.line = lineSegment;

./canvas/canvas.js 299                         _this.drawingLine.calculative.drawlineH =

./canvas/canvas.js 300                             !_this.drawingLine.calculative.drawlineH;

./canvas/canvas.js 336                         _this.drawingLine.lineName = _this.drawingLineName;

./canvas/canvas.js 337                         _this.drawline();

./canvas/canvas.js 463                             _this.finishDrawline();

./canvas/canvas.js 495                         _this.finishDrawline(true);

./canvas/canvas.js 496                         if (_this.store.active[0].anchors[0].connectTo) {

./canvas/canvas.js 507                                 _this.store.path2dMap.set(pen, globalStore.path2dDraws.line(pen));

./canvas/canvas.js 516                         _this.finishDrawline();

./canvas/canvas.js 775             // Set anchor of pen.

./canvas/canvas.js 785                     var anchor = _this.store.activeAnchor;

./canvas/canvas.js 788                         x: anchor.x,

./canvas/canvas.js 789                         y: anchor.y,

./canvas/canvas.js 794                     connectLine(_this.store.hover, anchor, _this.drawingLine, pt);

./canvas/canvas.js 795                     _this.drawline();

./canvas/canvas.js 813                     _this.drawline();

./canvas/canvas.js 814                     _this.finishDrawline(true);

./canvas/canvas.js 822                         var anchor = _this.store.activeAnchor;

./canvas/canvas.js 823                         to_2.x = anchor.x;

./canvas/canvas.js 824                         to_2.y = anchor.y;

./canvas/canvas.js 825                         connectLine(_this.store.hover, anchor, _this.drawingLine, to_2);

./canvas/canvas.js 826                         _this.drawline();

./canvas/canvas.js 827                         _this.finishDrawline(true);

./canvas/canvas.js 838                     _this.finishDrawline(true);

./canvas/canvas.js 839                     if ((_c = _this.store.active[0]) === null || _c === void 0 ? void 0 : _c.anchors[0].connectTo) {

./canvas/canvas.js 850                     var anchor = nearestAnchor(_this.store.hover, e);

./canvas/canvas.js 851                     to_3.x = anchor.x;

./canvas/canvas.js 852                     to_3.y = anchor.y;

./canvas/canvas.js 854                     connectLine(_this.store.hover, anchor, _this.drawingLine, to_3);

./canvas/canvas.js 855                     _this.drawline();

./canvas/canvas.js 856                     _this.finishDrawline(true);

./canvas/canvas.js 874                 _this.drawingLine.calculative.drawlineH = undefined;

./canvas/canvas.js 875                 _this.drawingLineName !== 'polyline' && _this.drawline();

./canvas/canvas.js 882                         var anchor = nearestAnchor(_this.store.hover, e);

./canvas/canvas.js 883                         _this.store.hoverAnchor = anchor;

./canvas/canvas.js 884                         var pt = { id: s8(), x: anchor.x, y: anchor.y };

./canvas/canvas.js 887                         connectLine(_this.store.hover, anchor, _this.drawingLine, pt);

./canvas/canvas.js 894                 else if (!_this.drawingLine && _this.drawingLineName !== 'curve') {

./canvas/canvas.js 1042                             _this.drawline();

./canvas/canvas.js 1051                         _this.drawline();

./canvas/canvas.js 1077                         // Move line anchor

./canvas/canvas.js 1090                         // Move line anchor prev

./canvas/canvas.js 1095                         // Move line anchor next

./canvas/canvas.js 1154                     _this.drawingLineName === 'curve' &&

./canvas/canvas.js 1156                     _this.drawline(pt);

./canvas/canvas.js 1182                         if (_this.drawingLineName === 'polyline') {

./canvas/canvas.js 1186                     if (_this.drawingLineName === 'line') {

./canvas/canvas.js 1250                     _this.drawline();

./canvas/canvas.js 1292                     _this.drawline();

./canvas/canvas.js 1293                     _this.finishDrawline(true);

./canvas/canvas.js 1299                     var anchor = nearestAnchor(_this.store.hover, e);

./canvas/canvas.js 1300                     to.x = anchor.x;

./canvas/canvas.js 1301                     to.y = anchor.y;

./canvas/canvas.js 1303                     connectLine(_this.store.hover, anchor, _this.drawingLine, to);

./canvas/canvas.js 1304                     _this.drawline();

./canvas/canvas.js 1305                     _this.finishDrawline(true);

./canvas/canvas.js 1313                 _this.store.active[0].name === 'line' &&

./canvas/canvas.js 1315                 var line_1 = _this.store.active[0];

./canvas/canvas.js 1316                 var from = getFromAnchor(line_1);

./canvas/canvas.js 1317                 var to = getToAnchor(line_1);

./canvas/canvas.js 1329                         var hoverAnchors = hover.calculative.worldAnchors.map(function (anchor) {

./canvas/canvas.js 1330                             return __assign(__assign({}, anchor), { penId: line_1.id });

./canvas/canvas.js 1342                             line_1.calculative.worldAnchors[0].connectTo = undefined;

./canvas/canvas.js 1343                             (_a = line_1.calculative.worldAnchors).unshift.apply(_a, __spreadArray([], __read(hoverAnchors), false));

./canvas/canvas.js 1346                             line_1.calculative.worldAnchors[line_1.calculative.worldAnchors.length - 1].connectTo = undefined;

./canvas/canvas.js 1347                             (_b = line_1.calculative.worldAnchors).push.apply(_b, __spreadArray([], __read(hoverAnchors), false));

./canvas/canvas.js 1358                             connectLine(_this.store.hover, _this.store.hoverAnchor, line_1, _this.store.activeAnchor);

./canvas/canvas.js 1361                     if (_this[line_1.lineName] && line_1.lineName !== 'polyline') {

./canvas/canvas.js 1362                         _this[line_1.lineName](_this.store, line_1);

./canvas/canvas.js 1364                     _this.store.path2dMap.set(line_1, globalStore.path2dDraws.line(line_1));

./canvas/canvas.js 1365                     _this.initLineRect(line_1);

./canvas/canvas.js 1369                     if (from === _this.store.activeAnchor && line_1.autoFrom) {

./canvas/canvas.js 1370                         _this.calcAutoAnchor(line_1, from, _this.store.hover);

./canvas/canvas.js 1372                     else if (to === _this.store.activeAnchor && line_1.autoTo) {

./canvas/canvas.js 1373                         _this.calcAutoAnchor(line_1, to, _this.store.hover);

./canvas/canvas.js 1407                             return lineInRect(pen, _this.dragRect);

./canvas/canvas.js 1616                                 var anchor = _d.value;

./canvas/canvas.js 1617                                 hoverType = _this.inAnchor(pt, pen, anchor);

./canvas/canvas.js 1666                     if (pen.name === 'line') {

./canvas/canvas.js 1667                         isIn = pointInSimpleRect(pt, pen.calculative.worldRect, pen.lineWidth);

./canvas/canvas.js 1763                 r += 2 * _this.store.options.anchorRadius;

./canvas/canvas.js 1773                                 var anchor = _e.value;

./canvas/canvas.js 1774                                 if (anchor.twoWay === TwoWay.In) {

./canvas/canvas.js 1780                                 if (anchor.twoWay === TwoWay.Out) {

./canvas/canvas.js 1786                                 if (anchor.twoWay === TwoWay.DisableConnected ||

./canvas/canvas.js 1787                                     anchor.twoWay === TwoWay.Disable ||

./canvas/canvas.js 1792                                 if (_this.inAnchor(pt, pen, anchor)) {

./canvas/canvas.js 1917                     // Draw rotate control line.

./canvas/canvas.js 1920                     ctx.lineTo(_this.activeRect.center.x, _this.activeRect.y - 30);

./canvas/canvas.js 1946                 var anchors = __spreadArray([], __read(_this.store.hover.calculative.worldAnchors), false);

./canvas/canvas.js 1948                     anchors.push(_this.store.pointAt);

./canvas/canvas.js 1950                 if (anchors) {

./canvas/canvas.js 1952                         _this.store.hover.anchorColor || _this.store.options.anchorColor;

./canvas/canvas.js 1954                         _this.store.hover.anchorBackground ||

./canvas/canvas.js 1955                             _this.store.options.anchorBackground;

./canvas/canvas.js 1956                     anchors.forEach(function (anchor) {

./canvas/canvas.js 1957                         if (anchor.hidden && anchor.locked > LockState.DisableEdit) {

./canvas/canvas.js 1960                         if (anchor === _this.store.hoverAnchor) {

./canvas/canvas.js 1968                         var size = anchor.radius ||

./canvas/canvas.js 1969                             _this.store.hover.anchorRadius ||

./canvas/canvas.js 1970                             _this.store.options.anchorRadius;

./canvas/canvas.js 1973                             if (_this.store.hover.calculative.lineWidth > 3) {

./canvas/canvas.js 1974                                 size = _this.store.hover.calculative.lineWidth;

./canvas/canvas.js 1977                         ctx.arc(anchor.x, anchor.y, size, 0, Math.PI * 2);

./canvas/canvas.js 1978                         if (_this.store.hover.type && _this.store.hoverAnchor === anchor) {

./canvas/canvas.js 1984                         else if (anchor.color || anchor.background) {

./canvas/canvas.js 1986                             ctx.strokeStyle = anchor.color;

./canvas/canvas.js 1987                             ctx.fillStyle = anchor.background;

./canvas/canvas.js 1991                         if (anchor === _this.store.hoverAnchor) {

./canvas/canvas.js 1994                         if (_this.store.hover.type && _this.store.hoverAnchor === anchor) {

./canvas/canvas.js 1997                         else if (anchor.color || anchor.background) {

./canvas/canvas.js 2004                             if (anchor === _this.store.hoverAnchor) {

./canvas/canvas.js 2007                                 ctx.lineWidth = 3;

./canvas/canvas.js 2013                                 ctx.arc(anchor.x, anchor.y, size + 1.5, 0, Math.PI * 2);

./canvas/canvas.js 2063                     ctx.lineTo(_this.dock.xDock.x, _this.dock.xDock.prev.y);

./canvas/canvas.js 2069                     ctx.lineTo(_this.dock.yDock.prev.x, _this.dock.yDock.y);

./canvas/canvas.js 2246             if (pen.textAlign && pen.whiteSpace === 'pre-line') {

./canvas/canvas.js 2254             if (pen.textBaseline) {

./canvas/canvas.js 2260                 style += "justify-content: " + baseLine[pen.textBaseline] + ";";

./canvas/canvas.js 2299             if (pen.lineHeight) {

./canvas/canvas.js 2300                 style += "line-height:" + (scale > 1

./canvas/canvas.js 2301                     ? pen.fontSize * pen.lineHeight * scale

./canvas/canvas.js 2302                     : pen.fontSize * pen.lineHeight * font_scale) + "px;";

./canvas/canvas.js 2317                 if (pen.whiteSpace !== 'pre-line') {

./canvas/canvas.js 2336                 // if (pen.whiteSpace === 'pre-line') {

./canvas/canvas.js 2342                 if (pen.whiteSpace === 'pre-line') {

./canvas/canvas.js 2358                     Math.floor(pen.height / scale / (pen.lineHeight * pen.fontSize));

./canvas/canvas.js 2365             sheet.insertRule(".meta2d-input\n      .input-div{\n        resize:none;border:none;outline:none;background:transparent;position:absolute;flex-grow:1;height:100%;width: 100%;position:absolute;left:0;top:0;display:flex;flex-direction: column;cursor: text;" + style + "}");

./canvas/canvas.js 2512         this.externalElements.style.outline = 'none';

./canvas/canvas.js 2628      * @param line 连线

./canvas/canvas.js 2629      * @param anchor 锚点，连线的某个锚点，引用相同

./canvas/canvas.js 2631     Canvas.prototype.splitLine = function (line, anchor) {

./canvas/canvas.js 2632         var worldAnchors = line.calculative.worldAnchors;

./canvas/canvas.js 2633         var index = worldAnchors.findIndex(function (a) { return a === anchor; });

./canvas/canvas.js 2638         var initLine = deepClone(line, true);

./canvas/canvas.js 2639         var newLine = deepClone(line, true);

./canvas/canvas.js 2651         line.calculative.worldAnchors = preAnchors;

./canvas/canvas.js 2653         this.initLineRect(line);

./canvas/canvas.js 2665             pens: [deepClone(line, true)],

./canvas/canvas.js 2690             var anchor = calcRelativePoint(this.movingAnchor, rect);

./canvas/canvas.js 2691             // 更改 pen 的 anchors 属性

./canvas/canvas.js 2692             var index = pen.anchors.findIndex(function (anchor) { return anchor.id === _this.movingAnchor.id; });

./canvas/canvas.js 2693             pen.anchors[index] = anchor;

./canvas/canvas.js 2893         var lineWidth = data.lineWidth || 1;

./canvas/canvas.js 2896             name: 'line',

./canvas/canvas.js 2905                 lineWidth: lineWidth * scale,

./canvas/canvas.js 2909             lineWidth: lineWidth,

./canvas/canvas.js 2920         var lineWidth = data.lineWidth || 1;

./canvas/canvas.js 2924             name: 'line',

./canvas/canvas.js 2925             lineName: this.drawingLineName,

./canvas/canvas.js 2933                 lineWidth: lineWidth * scale,

./canvas/canvas.js 2937             lineWidth: lineWidth,

./canvas/canvas.js 2945         var lineX = e.x;

./canvas/canvas.js 2946         var lineY = e.y;

./canvas/canvas.js 2953             lineX = -offsetX;

./canvas/canvas.js 2959             lineY = -offsetY;

./canvas/canvas.js 2970             name: 'line',

./canvas/canvas.js 2971             lineName: 'line',

./canvas/canvas.js 2972             x: lineX,

./canvas/canvas.js 2973             y: lineY,

./canvas/canvas.js 2977             anchors: [

./canvas/canvas.js 3040             ((xDock === null || xDock === void 0 ? void 0 : xDock.anchorId) || (yDock === null || yDock === void 0 ? void 0 : yDock.anchorId))) {

./canvas/canvas.js 3043             if (xDock === null || xDock === void 0 ? void 0 : xDock.anchorId) {

./canvas/canvas.js 3044                 var anchor = this.store.pens[this.store.active[0].id + movingSuffix].calculative.worldAnchors.find(function (item) { return item.id === xDock.anchorId; });

./canvas/canvas.js 3045                 if (anchor.x === from.x && anchor.y === from.y) {

./canvas/canvas.js 3047                     connectLine(this.store.active[0], anchor, dockPen, from);

./canvas/canvas.js 3050                 else if (anchor.x === to.x && anchor.y === to.y) {

./canvas/canvas.js 3052                     connectLine(this.store.active[0], anchor, dockPen, to);

./canvas/canvas.js 3056             else if (yDock === null || yDock === void 0 ? void 0 : yDock.anchorId) {

./canvas/canvas.js 3057                 var anchor = this.store.pens[this.store.active[0].id + movingSuffix].calculative.worldAnchors.find(function (item) { return item.id === yDock.anchorId; });

./canvas/canvas.js 3058                 if (anchor.x === from.x && anchor.y === from.y) {

./canvas/canvas.js 3060                     connectLine(this.store.active[0], anchor, dockPen, from);

./canvas/canvas.js 3063                 else if (anchor.x === to.x && anchor.y === to.y) {

./canvas/canvas.js 3065                     connectLine(this.store.active[0], anchor, dockPen, to);

./canvas/canvas.js 3086             // 若需要更改 anchors ，注意 anchors connectTo 问题

./canvas/canvas.js 3087             // const { x, y, width, height, anchors } = this.movingPens[i];

./canvas/canvas.js 3089              * TODO: line 类型无法取到移动后的 x，y 值

./canvas/canvas.js 3192     Canvas.prototype.inAnchor = function (pt, pen, anchor) {

./canvas/canvas.js 3196         if (!anchor || anchor.locked > LockState.DisableEdit) {

./canvas/canvas.js 3203             pen.name === 'line' &&

./canvas/canvas.js 3204             anchor.connectTo) {

./canvas/canvas.js 3205             var connectPen = this.findOne(anchor.connectTo);

./canvas/canvas.js 3208                 var connectAnchor = connectPen.calculative.worldAnchors.find(function (item) { return item.id === anchor.anchorId; });

./canvas/canvas.js 3209                 connectAnchor && (anchor = connectAnchor);

./canvas/canvas.js 3212         if (anchor.twoWay === TwoWay.Disable && pen.name !== 'line') {

./canvas/canvas.js 3215         if (pen.name === 'line' && anchor.connectTo) {

./canvas/canvas.js 3216             var _anchor = (_a = this.findOne(anchor.connectTo)) === null || _a === void 0 ? void 0 : _a.anchors.find(function (item) { return item.id === anchor.anchorId; });

./canvas/canvas.js 3217             if (_anchor && _anchor.twoWay) {

./canvas/canvas.js 3222             if (anchor.twoWay === TwoWay.Out) {

./canvas/canvas.js 3229             else if (anchor.twoWay === TwoWay.In) {

./canvas/canvas.js 3233         if (hitPoint(pt, anchor, this.pointSize)) {

./canvas/canvas.js 3234             if (anchor !== this.store.hoverAnchor) {

./canvas/canvas.js 3237             this.store.hoverAnchor = anchor;

./canvas/canvas.js 3239             // if (pen.name === 'line' && anchor.connectTo) {

./canvas/canvas.js 3240             //   const connectPen = this.findOne(anchor.connectTo);

./canvas/canvas.js 3244             //       (item) => item.id === anchor.anchorId

./canvas/canvas.js 3250             // console.log('hover', pen, anchor);

./canvas/canvas.js 3252                 if (anchor.connectTo && !pen.calculative.active) {

./canvas/canvas.js 3253                     this.store.hover = this.store.pens[anchor.connectTo];

./canvas/canvas.js 3256                             this.store.hover.calculative.worldAnchors.find(function (a) { return a.id === anchor.anchorId; });

./canvas/canvas.js 3279                 anchor.prev &&

./canvas/canvas.js 3280                 hitPoint(pt, anchor.prev, this.pointSize)) {

./canvas/canvas.js 3281                 this.store.hoverAnchor = anchor;

./canvas/canvas.js 3287                 anchor.next &&

./canvas/canvas.js 3288                 hitPoint(pt, anchor.next, this.pointSize)) {

./canvas/canvas.js 3289                 this.store.hoverAnchor = anchor;

./canvas/canvas.js 3330         this.offscreen.getContext('2d').textBaseline = 'middle';

./canvas/canvas.js 3525                             if (typeof pen[k] !== 'object' || k === 'lineDash') {

./canvas/canvas.js 3589         if (pen.lineWidth == undefined) {

./canvas/canvas.js 3590             pen.lineWidth = 1;

./canvas/canvas.js 3592         var _a = this.store.options, fontSize = _a.fontSize, lineHeight = _a.lineHeight;

./canvas/canvas.js 3596         if (!pen.lineHeight) {

./canvas/canvas.js 3597             pen.lineHeight = lineHeight;

./canvas/canvas.js 3606             if (typeof pen[k] !== 'object' || k === 'lineDash') {

./canvas/canvas.js 3613         if (!pen.anchors && globalStore.anchors[pen.name]) {

./canvas/canvas.js 3614             if (!pen.anchors) {

./canvas/canvas.js 3615                 pen.anchors = [];

./canvas/canvas.js 3617             globalStore.anchors[pen.name](pen);

./canvas/canvas.js 3620         if (!pen.anchors && pen.calculative.worldAnchors) {

./canvas/canvas.js 3621             pen.anchors = pen.calculative.worldAnchors.map(function (pt) {

./canvas/canvas.js 3628     Canvas.prototype.drawline = function (mouse) {

./canvas/canvas.js 3634         this.store.path2dMap.set(this.drawingLine, globalStore.path2dDraws.line(this.drawingLine));

./canvas/canvas.js 3656         var _b = this.store.options, fontSize = _b.fontSize, lineHeight = _b.lineHeight;

./canvas/canvas.js 3661         if (!pen.lineHeight) {

./canvas/canvas.js 3662             pen.lineHeight = lineHeight;

./canvas/canvas.js 3663             pen.calculative.lineHeight = pen.lineHeight;

./canvas/canvas.js 3672             pen.anchors = pen.calculative.worldAnchors.map(function (pt) {

./canvas/canvas.js 3687     Canvas.prototype.finishDrawline = function (end) {

./canvas/canvas.js 3689             var from, to, line, rect, allowAdd, _a;

./canvas/canvas.js 3721                                 line = this.store.data.pens.find(function (pen) {

./canvas/canvas.js 3728                                 if (line) {

./canvas/canvas.js 3772             var anchors, p, allowAdd, _a;

./canvas/canvas.js 3777                         anchors = simplify(this.pencilLine.calculative.worldAnchors, 10, 0, this.pencilLine.calculative.worldAnchors.length - 1);

./canvas/canvas.js 3779                         anchors.unshift({ id: p.id, penId: p.penId, x: p.x, y: p.y });

./canvas/canvas.js 3781                         anchors.push({ id: p.id, penId: p.penId, x: p.x, y: p.y });

./canvas/canvas.js 3782                         this.pencilLine.calculative.worldAnchors = smoothLine(anchors);

./canvas/canvas.js 3831             var inlineSVG = result.getElementsByTagName('svg')[0];

./canvas/canvas.js 3834             inlineSVG.setAttribute('width', width + "px");

./canvas/canvas.js 3835             inlineSVG.setAttribute('height', height + "px");

./canvas/canvas.js 3837             var svg64 = btoa(unescape(encodeURIComponent(new XMLSerializer().serializeToString(inlineSVG))));

./canvas/canvas.js 3944         pen.calculative.lineWidth = pen.lineWidth * scale;

./canvas/canvas.js 4087                 var lineScale = s > 1 ? 1 : 1 / s / s;

./canvas/canvas.js 4089                 var lineCenter = pen.calculative.worldRect.center;

./canvas/canvas.js 4092                     scalePen(pen, lineScale, lineCenter);

./canvas/canvas.js 4096                     scalePen(pen, lineScale, lineCenter);

./canvas/canvas.js 4261             (this.store.active[0].anchors[0].connectTo ||

./canvas/canvas.js 4262                 this.store.active[0].anchors[this.store.active[0].anchors.length - 1]

./canvas/canvas.js 4317             pen.connectedLines = pen.connectedLines.map(function (line) {

./canvas/canvas.js 4318                 if (pens.find(function (p) { return p.id === line.lineId; })) {

./canvas/canvas.js 4319                     line.lineId += movingSuffix;

./canvas/canvas.js 4321                 return line;

./canvas/canvas.js 4325             pen.calculative.worldAnchors = pen.calculative.worldAnchors.map(function (anchor) {

./canvas/canvas.js 4326                 if (anchor.connectTo && pens.find(function (p) { return p.id === anchor.connectTo; })) {

./canvas/canvas.js 4327                     anchor.connectTo += movingSuffix;

./canvas/canvas.js 4329                 return anchor;

./canvas/canvas.js 4343                 if (pen.anchors[0].connectTo ||

./canvas/canvas.js 4344                     pen.anchors[pen.anchors.length - 1].connectTo) {

./canvas/canvas.js 4363             pen.lineWidth === 0 && (value.lineWidth = 1);

./canvas/canvas.js 4385             disconnectLine(pen, getAnchor(pen, this.store.activeAnchor.anchorId), this.store.pens[this.store.activeAnchor.penId], this.store.activeAnchor);

./canvas/canvas.js 4387         var line = this.store.active[0];

./canvas/canvas.js 4388         var from = getFromAnchor(line);

./canvas/canvas.js 4389         var to = getToAnchor(line);

./canvas/canvas.js 4390         if (line.lineName === 'polyline' && !keyOptions.shiftKey) {

./canvas/canvas.js 4391             translatePolylineAnchor(line, this.store.activeAnchor, pt);

./canvas/canvas.js 4405                 if (line.lineName !== 'polyline') {

./canvas/canvas.js 4406                     (_b = this[line.lineName]) === null || _b === void 0 ? void 0 : _b.call(this, this.store, line);

./canvas/canvas.js 4410         this.patchFlagsLines.add(line);

./canvas/canvas.js 4411         this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));

./canvas/canvas.js 4453         var line = this.store.active[0];

./canvas/canvas.js 4454         this.patchFlagsLines.add(line);

./canvas/canvas.js 4455         this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));

./canvas/canvas.js 4495         var line = this.store.active[0];

./canvas/canvas.js 4496         this.patchFlagsLines.add(line);

./canvas/canvas.js 4497         this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));

./canvas/canvas.js 4584      * @param line 连线

./canvas/canvas.js 4587     Canvas.prototype.checkDisconnect = function (line, pens) {

./canvas/canvas.js 4589         if (line.id.indexOf(movingSuffix) > 0) {

./canvas/canvas.js 4590             var id = line.id;

./canvas/canvas.js 4591             line = this.store.pens[id.replace(movingSuffix, '')];

./canvas/canvas.js 4594         line.anchors.forEach(function (anchor) {

./canvas/canvas.js 4595             if (anchor.connectTo &&

./canvas/canvas.js 4597                     return p.id === anchor.connectTo ||

./canvas/canvas.js 4598                         p.id === anchor.connectTo + movingSuffix;

./canvas/canvas.js 4600                 var pen = _this.store.pens[anchor.connectTo];

./canvas/canvas.js 4604                 disconnectLine(pen, getAnchor(pen, anchor.anchorId), line, anchor);

./canvas/canvas.js 4646                         var line = _this.store.pens[item.lineId];

./canvas/canvas.js 4647                         _this.initLineRect(line);

./canvas/canvas.js 4683     Canvas.prototype.calcAutoAnchor = function (line, lineAnchor, pen, penConnection) {

./canvas/canvas.js 4684         var from = getFromAnchor(line);

./canvas/canvas.js 4685         var to = getToAnchor(line);

./canvas/canvas.js 4686         var newAnchor = nearestAnchor(pen, lineAnchor === from ? to : from);

./canvas/canvas.js 4687         lineAnchor.x = newAnchor.x;

./canvas/canvas.js 4688         lineAnchor.y = newAnchor.y;

./canvas/canvas.js 4689         lineAnchor.prev = undefined;

./canvas/canvas.js 4690         lineAnchor.next = undefined;

./canvas/canvas.js 4692             penConnection.anchor = newAnchor.id;

./canvas/canvas.js 4695             connectLine(pen, newAnchor, line, lineAnchor);

./canvas/canvas.js 4697         if (this[line.lineName]) {

./canvas/canvas.js 4698             this[line.lineName](this.store, line);

./canvas/canvas.js 4700         this.store.path2dMap.set(line, globalStore.path2dDraws.line(line));

./canvas/canvas.js 4701         this.initLineRect(line);

./canvas/canvas.js 4716                         (typeof pen[k] !== 'object' || k === 'lineDash')) {

./canvas/canvas.js 4736                         (typeof pen[k] !== 'object' || k === 'lineDash')) {

./canvas/canvas.js 4774                 // 每个子节点都会更新 line，包括子节点是 type 1 的情况

./canvas/canvas.js 4782             var line = _this.store.pens[item.lineId];

./canvas/canvas.js 4784             if (!line || line.calculative.active) {

./canvas/canvas.js 4787             var lineAnchor = getAnchor(line, item.lineAnchor);

./canvas/canvas.js 4788             if (!lineAnchor) {

./canvas/canvas.js 4791             if (line.autoFrom) {

./canvas/canvas.js 4792                 var from = getFromAnchor(line);

./canvas/canvas.js 4793                 if (from.id === lineAnchor.id) {

./canvas/canvas.js 4794                     _this.calcAutoAnchor(line, from, pen, item);

./canvas/canvas.js 4797             if (line.autoTo) {

./canvas/canvas.js 4798                 var to = getToAnchor(line);

./canvas/canvas.js 4799                 if (to.id === lineAnchor.id) {

./canvas/canvas.js 4800                     _this.calcAutoAnchor(line, to, pen, item);

./canvas/canvas.js 4803             var penAnchor = getAnchor(pen, item.anchor);

./canvas/canvas.js 4807             translatePoint(lineAnchor, penAnchor.x - lineAnchor.x, penAnchor.y - lineAnchor.y);

./canvas/canvas.js 4808             if (_this.store.options.autoPolyline &&

./canvas/canvas.js 4809                 line.autoPolyline !== false &&

./canvas/canvas.js 4810                 line.lineName === 'polyline') {

./canvas/canvas.js 4811                 var from = getFromAnchor(line);

./canvas/canvas.js 4812                 var to = getToAnchor(line);

./canvas/canvas.js 4814                 if (from.id === lineAnchor.id) {

./canvas/canvas.js 4815                     from = lineAnchor;

./canvas/canvas.js 4818                 else if (to.id === lineAnchor.id) {

./canvas/canvas.js 4819                     to = lineAnchor;

./canvas/canvas.js 4823                     line.calculative.worldAnchors = [from, to];

./canvas/canvas.js 4824                     line.calculative.activeAnchor = from;

./canvas/canvas.js 4825                     _this.polyline(_this.store, line, to);

./canvas/canvas.js 4826                     _this.initLineRect(line);

./canvas/canvas.js 4829             _this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));

./canvas/canvas.js 4830             _this.patchFlagsLines.add(line);

./canvas/canvas.js 4831             change && getLineLength(line);

./canvas/canvas.js 4863             pen.calculative.worldAnchors.forEach(function (anchor) {

./canvas/canvas.js 4864                 rotatePoint(anchor, angle, rect.center);

./canvas/canvas.js 5008                                 if (typeof pen[k] !== 'object' || k === 'lineDash') {

./canvas/canvas.js 5016                                 if (typeof pen[k] !== 'object' || k === 'lineDash') {

./canvas/canvas.js 5219      * 修改对应连线的 anchors

./canvas/canvas.js 5229             var lineId = pen.connectedLines[index].lineId;

./canvas/canvas.js 5230             var line = pastePens.find(function (pen) { return pen.id === lineId; });

./canvas/canvas.js 5231             if (line) {

./canvas/canvas.js 5232                 var from = line.anchors[0];

./canvas/canvas.js 5233                 var to = line.anchors[line.anchors.length - 1];

./canvas/canvas.js 5253      * @param line 线

./canvas/canvas.js 5256     Canvas.prototype.changeNodeConnectedLine = function (oldId, line, pastePens) {

./canvas/canvas.js 5259         var from = line.anchors[0];

./canvas/canvas.js 5260         var to = line.anchors[line.anchors.length - 1];

./canvas/canvas.js 5262         var anchors = [from, to];

./canvas/canvas.js 5263         var _loop_7 = function (anchor) {

./canvas/canvas.js 5264             var nodeId = anchor.connectTo;

./canvas/canvas.js 5269                         if (cl.lineId === oldId) {

./canvas/canvas.js 5270                             cl.lineId = line.id;

./canvas/canvas.js 5271                             cl.lineAnchor = anchor.id;

./canvas/canvas.js 5277                     anchor.connectTo = undefined;

./canvas/canvas.js 5278                     if (anchor.prev) {

./canvas/canvas.js 5279                         anchor.prev.connectTo = undefined;

./canvas/canvas.js 5281                     if (anchor.next) {

./canvas/canvas.js 5282                         anchor.next.connectTo = undefined;

./canvas/canvas.js 5288             for (var anchors_1 = __values(anchors), anchors_1_1 = anchors_1.next(); !anchors_1_1.done; anchors_1_1 = anchors_1.next()) {

./canvas/canvas.js 5289                 var anchor = anchors_1_1.value;

./canvas/canvas.js 5290                 _loop_7(anchor);

./canvas/canvas.js 5296                 if (anchors_1_1 && !anchors_1_1.done && (_a = anchors_1.return)) _a.call(anchors_1);

./canvas/canvas.js 5335                         // TODO: 连线的删除 ，连接的 node 的 connectLines 会变化（删除 node ，line 的 anchors 类似），未记历史记录

./canvas/canvas.js 5436                 var _b = pen.connectedLines[i], lineId = _b.lineId, lineAnchor = _b.lineAnchor;

./canvas/canvas.js 5437                 var line = this_2.store.pens[lineId];

./canvas/canvas.js 5438                 if (line) {

./canvas/canvas.js 5439                     var anchor = line.anchors.find(function (anchor) { return anchor.id === lineAnchor; });

./canvas/canvas.js 5440                     if ((anchor === null || anchor === void 0 ? void 0 : anchor.connectTo) === pen.id) {

./canvas/canvas.js 5441                         anchor.connectTo = undefined;

./canvas/canvas.js 5442                         anchor.anchorId = undefined;

./canvas/canvas.js 5443                         anchor.prev && (anchor.prev.connectTo = undefined);

./canvas/canvas.js 5444                         anchor.next && (anchor.next.connectTo = undefined);

./canvas/canvas.js 5446                     anchor = getAnchor(line, lineAnchor);

./canvas/canvas.js 5447                     if (anchor) {

./canvas/canvas.js 5448                         anchor.connectTo = undefined;

./canvas/canvas.js 5449                         anchor.anchorId = undefined;

./canvas/canvas.js 5450                         anchor.prev && (anchor.prev.connectTo = undefined);

./canvas/canvas.js 5451                         anchor.next && (anchor.next.connectTo = undefined);

./canvas/canvas.js 5463         (_a = pen.calculative.worldAnchors) === null || _a === void 0 ? void 0 : _a.forEach(function (lineAnchor, index) {

./canvas/canvas.js 5465             if (!lineAnchor.connectTo) {

./canvas/canvas.js 5468             var connectTo = _this.store.pens[lineAnchor.connectTo];

./canvas/canvas.js 5470                 (_a = connectTo.calculative.worldAnchors) === null || _a === void 0 ? void 0 : _a.forEach(function (anchor) {

./canvas/canvas.js 5471                     disconnectLine(connectTo, anchor, pen, lineAnchor);

./canvas/canvas.js 5505             sheet.insertRule('.meta2d-input{display:none;position:absolute;outline:none;align-items: center;}');

./canvas/canvas.js 5506             sheet.insertRule('.meta2d-input textarea{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;left:0;top:0}');

./canvas/canvas.js 5509             sheet.insertRule('.meta2d-input ul li{padding: 5px 12px;line-height: 22px;white-space: nowrap;cursor: pointer;}');

./canvas/canvas.js 5512             sheet.insertRule('.meta2d-input .input-div{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;width: 100%;left:0;top:0;display:flex;text-align: center;justify-content: center;flex-direction: column;}');

./canvas/canvas.js 5623                 var lineId = _a.lineId;

./canvas/canvas.js 5624                 var line = _this.store.pens[lineId];

./canvas/canvas.js 5625                 calcWorldAnchors(line);

./canvas/canvas.js 5649             if (typeof pen[k] !== 'object' || k === 'lineDash') {

./canvas/canvas.js 5831         ctx.textBaseline = 'middle'; // 默认垂直居中

./canvas/magnifierCanvas.js 30         this.offscreen.getContext('2d').textBaseline = 'middle';

./canvas/magnifierCanvas.js 46         ctx.lineWidth = 5;

./canvas/canvasImage.js 52         this.otherOffsreen.getContext('2d').textBaseline = 'middle';

./canvas/canvasImage.js 56         this.offscreen.getContext('2d').textBaseline = 'middle';

./canvas/canvasImage.js 60         this.animateOffsScreen.getContext('2d').textBaseline = 'middle';

./canvas/canvasImage.js 252         ctx.lineWidth = 1;

./canvas/canvasImage.js 260             ctx.lineTo(i, longSide * 2);

./canvas/canvasImage.js 264             ctx.lineTo(longSide * 2, i);

./canvas/canvasImage.js 285         ctx.lineWidth = 12;

./canvas/canvasImage.js 286         ctx.lineDashOffset = -x % span;

./canvas/canvasImage.js 289         ctx.lineTo(width, 0);

./canvas/canvasImage.js 293         ctx.lineDashOffset = -y % span;

./canvas/canvasImage.js 295         ctx.lineTo(0, height);

./canvas/canvasImage.js 300         ctx.lineWidth = 24;

./canvas/canvasImage.js 301         ctx.lineDashOffset = -x % (span * 10);

./canvas/canvasImage.js 304         ctx.lineTo(width, 0);

./canvas/canvasImage.js 307         ctx.lineDashOffset = -y % (span * 10);

./canvas/canvasImage.js 309         ctx.lineTo(0, height);

./pen/model.js 43     'lineHeight',

./pen/model.js 47     'textBaseline',

./pen/model.js 96     'lineDash',

./pen/model.js 97     'lineCap',

./pen/model.js 98     'lineJoin',

./pen/model.js 100     'lineGradientFromColor',

./pen/model.js 101     'lineGradientToColor',

./pen/model.js 102     'lineGradientAngle',

./pen/model.js 106     'lineWidth',

./pen/model.js 115     'anchorColor',

./pen/model.js 116     'anchorRadius',

./pen/model.js 131     'textBaseline',

./pen/model.js 132     'lineHeight',

./pen/model.js 143     'lineWidth',

./pen/model.js 144     'lineAnimateType',

./pen/render.js 86     return linearGradient(ctx, worldRect, gradientFromColor, gradientToColor, gradientAngle);

./pen/render.js 112     var _a = pen.calculative, worldRect = _a.worldRect, lineGradientFromColor = _a.lineGradientFromColor, lineGradientToColor = _a.lineGradientToColor, lineGradientAngle = _a.lineGradientAngle;

./pen/render.js 113     return linearGradient(ctx, worldRect, lineGradientFromColor, lineGradientToColor, lineGradientAngle);

./pen/render.js 121 function linearGradient(ctx, worldRect, fromColor, toColor, angle) {

./pen/render.js 244     var _a = pen.calculative, fontStyle = _a.fontStyle, fontWeight = _a.fontWeight, fontSize = _a.fontSize, fontFamily = _a.fontFamily, lineHeight = _a.lineHeight, text = _a.text, hiddenText = _a.hiddenText, canvas = _a.canvas, textHasShadow = _a.textHasShadow, textBackground = _a.textBackground;

./pen/render.js 268         lineHeight: lineHeight,

./pen/render.js 280     var oneRowHeight = fontSize * lineHeight;

./pen/render.js 299     var _b = pen.calculative, fontStyle = _b.fontStyle, fontWeight = _b.fontWeight, fontSize = _b.fontSize, fontFamily = _b.fontFamily, lineHeight = _b.lineHeight, canvas = _b.canvas;

./pen/render.js 315         lineHeight: lineHeight,

./pen/render.js 322             var anchor = _d.value;

./pen/render.js 324                 prev = anchor;

./pen/render.js 327             var dis = distance(prev, anchor);

./pen/render.js 333             var angle = calcRotate(prev, anchor) - 270;

./pen/render.js 342             ctx.fillText(t, prev.x, prev.y + lineHeight / 2);

./pen/render.js 344             prev = anchor;

./pen/render.js 364     ctx.textBaseline = 'middle';

./pen/render.js 371             ctx.textBaseline = 'top';

./pen/render.js 375             ctx.textBaseline = 'bottom';

./pen/render.js 389             ctx.textBaseline = 'top';

./pen/render.js 395             ctx.textBaseline = 'top';

./pen/render.js 401             ctx.textBaseline = 'bottom';

./pen/render.js 407             ctx.textBaseline = 'bottom';

./pen/render.js 442     var _b = _a === void 0 ? {} : _a, _c = _b.fontStyle, fontStyle = _c === void 0 ? 'normal' : _c, _d = _b.textDecoration, textDecoration = _d === void 0 ? 'normal' : _d, _e = _b.fontWeight, fontWeight = _e === void 0 ? 'normal' : _e, _f = _b.fontSize, fontSize = _f === void 0 ? 12 : _f, _g = _b.fontFamily, fontFamily = _g === void 0 ? 'Arial' : _g, _h = _b.lineHeight, lineHeight = _h === void 0 ? 1 : _h;

./pen/render.js 443     return fontStyle + " " + textDecoration + " " + fontWeight + " " + fontSize + "px/" + lineHeight + " " + fontFamily;

./pen/render.js 478     if (pen.calculative.rotate && pen.name !== 'line') {

./pen/render.js 481     if (pen.calculative.lineWidth > 1) {

./pen/render.js 482         ctx.lineWidth = pen.calculative.lineWidth;

./pen/render.js 553     if (pen.calculative.lineDash) {

./pen/render.js 554         ctx.setLineDash(pen.calculative.lineDash);

./pen/render.js 556     if (pen.calculative.lineDashOffset) {

./pen/render.js 557         ctx.lineDashOffset = pen.calculative.lineDashOffset;

./pen/render.js 589  * 更改 ctx 的 lineCap 属性

./pen/render.js 592     var lineCap = pen.lineCap || (pen.type ? 'round' : 'square');

./pen/render.js 593     if (lineCap) {

./pen/render.js 594         ctx.lineCap = lineCap;

./pen/render.js 597         ctx.lineCap = 'round';

./pen/render.js 601  * 更改 ctx 的 lineJoin 属性

./pen/render.js 604     var lineJoin = pen.lineJoin;

./pen/render.js 605     if (lineJoin) {

./pen/render.js 606         ctx.lineJoin = lineJoin;

./pen/render.js 609         ctx.lineJoin = 'round';

./pen/render.js 646     if (pen.calculative.rotate && pen.name !== 'line') {

./pen/render.js 649     if (pen.calculative.lineWidth > 1) {

./pen/render.js 650         ctx.lineWidth = pen.calculative.lineWidth;

./pen/render.js 688     if (pen.calculative.lineDash) {

./pen/render.js 689         ctx.setLineDash(pen.calculative.lineDash);

./pen/render.js 691     if (pen.calculative.lineDashOffset) {

./pen/render.js 692         ctx.lineDashOffset = pen.calculative.lineDashOffset;

./pen/render.js 746             var lineWidth = pen.calculative.lineWidth + pen.calculative.borderWidth;

./pen/render.js 747             ctx.lineWidth = lineWidth;

./pen/render.js 751                 lineWidth && ctx.stroke(path);

./pen/render.js 756                 lineWidth && ctx.stroke();

./pen/render.js 792         if (pen.calculative.lineWidth) {

./pen/render.js 823  * 设置线条动画，ctx 的 strokeStyle lineDash 等属性更改

./pen/render.js 828     switch (pen.lineAnimateType) {

./pen/render.js 831                 ctx.lineDashOffset = pen.calculative.animatePos;

./pen/render.js 834                 ctx.lineDashOffset = pen.length - pen.calculative.animatePos;

./pen/render.js 836             len = pen.calculative.lineWidth || 5;

./pen/render.js 846                 ctx.lineDashOffset = pen.calculative.animatePos;

./pen/render.js 849                 ctx.lineDashOffset = pen.length - pen.calculative.animatePos;

./pen/render.js 852                 pen.calculative.animateDotSize || pen.calculative.lineWidth * 2 || 6;

./pen/render.js 856             ctx.lineWidth = len;

./pen/render.js 886     ctx.lineWidth = 1;

./pen/render.js 899     if (pen.calculative.lineWidth > 3) {

./pen/render.js 900         r = pen.calculative.lineWidth;

./pen/render.js 908             ctx.lineTo(pt.x, pt.y);

./pen/render.js 924             ctx.lineTo(pt.next.x, pt.next.y);

./pen/render.js 1021     var anchors = [];

./pen/render.js 1022     if (pen.anchors) {

./pen/render.js 1023         pen.anchors.forEach(function (anchor) {

./pen/render.js 1024             anchors.push(calcWorldPointOfPen(pen, anchor));

./pen/render.js 1027     // Default anchors of node

./pen/render.js 1028     if (!anchors.length &&

./pen/render.js 1032         anchors = store.options.defaultAnchors.map(function (anchor, index) {

./pen/render.js 1036                 x: x_1 + width_1 * anchor.x,

./pen/render.js 1037                 y: y_1 + height_1 * anchor.y,

./pen/render.js 1042         anchors.forEach(function (anchor) {

./pen/render.js 1043             rotatePoint(anchor, pen.calculative.rotate, pen.calculative.worldRect.center);

./pen/render.js 1046     if (!pen.type || pen.anchors) {

./pen/render.js 1047         pen.calculative.worldAnchors = anchors;

./pen/render.js 1049     if (pen.calculative.activeAnchor && anchors.length) {

./pen/render.js 1050         pen.calculative.activeAnchor = anchors.find(function (a) {

./pen/render.js 1129     if (!pen.anchors) {

./pen/render.js 1130         pen.anchors = [];

./pen/render.js 1146         var anchor = {

./pen/render.js 1152         pen.anchors.push(anchor);

./pen/render.js 1157     if (!pen.anchors) {

./pen/render.js 1158         pen.anchors = [];

./pen/render.js 1165     pen.anchors.splice(index + 1, 0, calcRelativePoint(worldAnchor, pen.calculative.worldRect));

./pen/render.js 1169 export function removePenAnchor(pen, anchor) {

./pen/render.js 1173     var i = pen.calculative.worldAnchors.findIndex(function (a) { return a.id === anchor.id; });

./pen/render.js 1177     i = pen.anchors.findIndex(function (a) { return a.id === anchor.id; });

./pen/render.js 1179         pen.anchors.splice(i, 1);

./pen/render.js 1190     var anchor;

./pen/render.js 1195             anchor = a;

./pen/render.js 1198     return anchor;

./pen/render.js 1203     if (pen.anchors) {

./pen/render.js 1204         pen.anchors.forEach(function (a) {

./pen/render.js 1218         if (!pen.anchors || !pen.anchors.length) {

./pen/render.js 1238  * 添加line到pen的connectedLines中，并关联相关属性

./pen/render.js 1241 export function connectLine(pen, anchor, line, lineAnchor) {

./pen/render.js 1243         !anchor ||

./pen/render.js 1244         !line ||

./pen/render.js 1245         !lineAnchor ||

./pen/render.js 1246         anchor.twoWay === TwoWay.DisableConnected ||

./pen/render.js 1247         anchor.twoWay === TwoWay.Disable ||

./pen/render.js 1248         lineAnchor.twoWay === TwoWay.DisableConnectTo ||

./pen/render.js 1249         lineAnchor.twoWay === TwoWay.Disable) {

./pen/render.js 1252     if (anchor.twoWay === TwoWay.In) {

./pen/render.js 1253         if (line.calculative.worldAnchors.length === 1) {

./pen/render.js 1256         var to = getToAnchor(line);

./pen/render.js 1257         if (lineAnchor.id !== to.id) {

./pen/render.js 1261     if (anchor.twoWay === TwoWay.Out) {

./pen/render.js 1262         var from = getFromAnchor(line);

./pen/render.js 1263         if (lineAnchor.id !== from.id) {

./pen/render.js 1267     if (lineAnchor.connectTo === pen.id && lineAnchor.anchorId === anchor.id) {

./pen/render.js 1270     if (lineAnchor.connectTo) {

./pen/render.js 1271         var p = pen.calculative.canvas.store.pens[lineAnchor.connectTo];

./pen/render.js 1272         disconnectLine(p, getAnchor(p, lineAnchor.anchorId), line, lineAnchor);

./pen/render.js 1278         return item.lineId === line.id &&

./pen/render.js 1279             item.lineAnchor === lineAnchor.id &&

./pen/render.js 1280             item.anchor === anchor.id;

./pen/render.js 1284             lineId: line.id,

./pen/render.js 1285             lineAnchor: lineAnchor.id,

./pen/render.js 1286             anchor: anchor.id,

./pen/render.js 1289     lineAnchor.connectTo = pen.id;

./pen/render.js 1290     lineAnchor.anchorId = anchor.id;

./pen/render.js 1293         connectLine(line, lineAnchor, pen, anchor);

./pen/render.js 1296         line: line,

./pen/render.js 1297         lineAnchor: lineAnchor,

./pen/render.js 1299         anchor: anchor,

./pen/render.js 1304  * 从 pen.connectedLines 中删除 lineId 和 lineAnchor

./pen/render.js 1306 export function disconnectLine(pen, anchor, line, lineAnchor) {

./pen/render.js 1307     if (!pen || !anchor || !line || !lineAnchor) {

./pen/render.js 1314         if ((item.lineId === line.id || item.lineId === line.id) &&

./pen/render.js 1315             item.lineAnchor === lineAnchor.id &&

./pen/render.js 1316             item.anchor === anchor.id) {

./pen/render.js 1320     lineAnchor.connectTo = undefined;

./pen/render.js 1321     lineAnchor.anchorId = undefined;

./pen/render.js 1324         anchor.connectTo === line.id &&

./pen/render.js 1325         anchor.anchorId === lineAnchor.id) {

./pen/render.js 1326         disconnectLine(line, lineAnchor, pen, anchor);

./pen/render.js 1329         line: line,

./pen/render.js 1330         lineAnchor: lineAnchor,

./pen/render.js 1332         anchor: anchor,

./pen/render.js 1336 export function getAnchor(pen, anchorId) {

./pen/render.js 1338     if (!pen || !anchorId) {

./pen/render.js 1341     return (_a = pen.calculative.worldAnchors) === null || _a === void 0 ? void 0 : _a.find(function (item) { return item.id === anchorId; });

./pen/render.js 1477         if (typeof pen[k] !== 'object' || k === 'lineDash') {

./pen/render.js 1574  * 值类型为 number , pen.linear 为 false 时，且 key 不属于 noLinear 时，返回 true

./pen/render.js 1584         pen.linear !== false &&

./pen/render.js 1657     elem.style.outline = 'none';

./pen/render.js 1662     elem.style.display = pen.calculative.inView != false ? 'inline' : 'none'; // 是否隐藏元素

./pen/render.js 1714         pen.calculative.worldAnchors.forEach(function (anchor) {

./pen/render.js 1715             rotatePoint(anchor, angle, rect.center);

./pen/render.js 1759     var _b = pen.calculative.canvas.store.options, fontSize = _b.fontSize, lineHeight = _b.lineHeight;

./pen/render.js 1765     if (!pen.lineHeight) {

./pen/render.js 1766         pen.lineHeight = lineHeight;

./pen/render.js 1767         pen.calculative.lineHeight = pen.lineHeight;

./pen/render.js 1774         pen.anchors = pen.calculative.worldAnchors.map(function (pt) {

./pen/arrow.js 68     ctx.lineTo(point.x, point.y);

./pen/arrow.js 69     ctx.lineTo(fromX, point.y + point.step / 4);

./pen/arrow.js 78     if (ctx.lineWidth < 2) {

./pen/arrow.js 79         ctx.lineWidth = 2;

./pen/arrow.js 86     ctx.lineTo(point.x, point.y);

./pen/arrow.js 87     ctx.lineTo(fromX, point.y + point.step / 4);

./pen/arrow.js 126     ctx.lineTo(fromX + r, point.y - r / 2);

./pen/arrow.js 127     ctx.lineTo(point.x, point.y);

./pen/arrow.js 128     ctx.lineTo(fromX + r, point.y + r / 2);

./pen/arrow.js 143     ctx.lineTo(fromX + r, point.y - r / 2);

./pen/arrow.js 144     ctx.lineTo(point.x, point.y);

./pen/arrow.js 145     ctx.lineTo(fromX + r, point.y + r / 2);

./pen/arrow.js 152 arrows.line = function (ctx, pen, store, point) {

./pen/arrow.js 159     ctx.lineTo(point.x, point.y);

./pen/arrow.js 160     ctx.lineTo(fromX, point.y + point.step / 3);

./pen/arrow.js 164 arrows.lineUp = function (ctx, pen, store, point) {

./pen/arrow.js 171     ctx.lineTo(point.x, point.y);

./pen/arrow.js 175 arrows.lineDown = function (ctx, pen, store, point) {

./pen/arrow.js 182     ctx.lineTo(point.x, point.y);

./pen/text.js 65     var textBaseline = pen.textBaseline || canvas.store.options.textBaseline;

./pen/text.js 74     switch (textBaseline) {

./pen/text.js 95     var lineHeight = pen.calculative.fontSize * pen.calculative.lineHeight;

./pen/text.js 96     var h = pen.calculative.textLines.length * lineHeight;

./pen/text.js 111     var textBaseline = pen.textBaseline || options.textBaseline;

./pen/text.js 112     switch (textBaseline) {

./pen/text.js 136     var lines = [];

./pen/text.js 137     var oneRowHeight = pen.calculative.fontSize * pen.calculative.lineHeight;

./pen/text.js 147                     lines.push(allLines[0]);

./pen/text.js 150                         setEllipsisOnLastLine(lines);

./pen/text.js 155                 lines.push(text);

./pen/text.js 158         case 'pre-line':

./pen/text.js 159             lines = text.split(/[\n]/g);

./pen/text.js 160             if (pen.ellipsis !== false && lines.length > maxRows) {

./pen/text.js 161                 lines = lines.slice(0, maxRows);

./pen/text.js 162                 setEllipsisOnLastLine(lines);

./pen/text.js 185                                     setEllipsisOnLastLine(lines);

./pen/text.js 189                                     lines.push(l);

./pen/text.js 202                         lines.push.apply(lines, __spreadArray([], __read(items), false));

./pen/text.js 217         lines.forEach(function (text, i) {

./pen/text.js 220                 lines[i] = textNum.toFixed(keepDecimal);

./pen/text.js 224     pen.calculative.textLines = lines;

./pen/text.js 225     return lines;

./pen/text.js 252     var _a = pen.calculative, fontStyle = _a.fontStyle, fontWeight = _a.fontWeight, fontSize = _a.fontSize, fontFamily = _a.fontFamily, lineHeight = _a.lineHeight;

./pen/text.js 254     var lines = [];

./pen/text.js 266                 lineHeight: lineHeight,

./pen/text.js 284             currentLine.length && lines.push(currentLine);

./pen/text.js 288     currentLine.length && lines.push(currentLine);

./pen/text.js 290     return lines;

./pen/text.js 306  * @param lines

./pen/text.js 308 function setEllipsisOnLastLine(lines) {

./pen/text.js 309     lines[lines.length - 1] = lines[lines.length - 1].slice(0, -3) + '...';

./pen/utils.js 16     if (Array.isArray(pen.anchors)) {

./pen/utils.js 18             for (var _b = __values(pen.anchors), _c = _b.next(); !_c.done; _c = _b.next()) {

./pen/math.js 202                                 anchorId: activePoint.id,

./pen/math.js 217                                 anchorId: activePoint.id,

./pen/math.js 247  * 判断 line 是否是 active 的连接线（并且计算子节点）

./pen/math.js 250  * @param line 连线

./pen/math.js 253 function isConnectLine(store, active, line) {

./pen/math.js 255     if (!line.type) {

./pen/math.js 261                 var cline = _d.value;

./pen/math.js 262                 if (cline.lineId === line.id) {

./pen/math.js 281                 if (isConnectLine(store, child, line)) {

./store/global.js 6     anchors: {},

./store/global.js 15 export function registerAnchors(anchorsFns) {

./store/global.js 16     Object.assign(globalStore.anchors, anchorsFns);

./rect/rect.js 212  * @param line1 线段1

./rect/rect.js 213  * @param line2 线段2

./rect/rect.js 215 function getIntersectPoint(line1, line2) {

./rect/rect.js 216     var k1 = (line1.to.y - line1.from.y) / (line1.to.x - line1.from.x);

./rect/rect.js 217     var k2 = (line2.to.y - line2.from.y) / (line2.to.x - line2.from.x);

./rect/rect.js 220         point: line1.from,

./rect/rect.js 223         point: line2.from,

./rect/rect.js 228  * @param line1 线段1

./rect/rect.js 229  * @param line2 线段2

./rect/rect.js 232 function getIntersectPointByK(line1, line2) {

./rect/rect.js 233     if (isEqual(line1.k, 0)) {

./rect/rect.js 235             x: line2.point.x,

./rect/rect.js 236             y: line1.point.y,

./rect/rect.js 239     else if (isEqual(line2.k, 0)) {

./rect/rect.js 241             x: line1.point.x,

./rect/rect.js 242             y: line2.point.y,

./rect/rect.js 245     var b1 = line1.point.y - line1.k * line1.point.x;

./rect/rect.js 246     var b2 = line2.point.y - line2.k * line2.point.x;

./rect/rect.js 247     var x = (b2 - b1) / (line1.k - line2.k);

./rect/rect.js 248     var y = line1.k * x + b1;

./rect/rect.js 416  * 计算相对点 ，anchors 中的值都是百分比

./rect/triangle.js 4     path.lineTo(pen.calculative.worldRect.x + pen.calculative.worldRect.width, pen.calculative.worldRect.y + pen.calculative.worldRect.height);

./rect/triangle.js 5     path.lineTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + pen.calculative.worldRect.height);

./rect/triangle.js 6     path.lineTo(pen.calculative.worldRect.x + pen.calculative.worldRect.width / 2, pen.calculative.worldRect.y);

./tooltip/tooltip.js 39             sheet.insertRule('.meta2d-tooltip .text{max-width:320px;min-height:30px;max-height:400px;outline:none;padding:8px 16px;border-radius:4px;background:#777777;color:#ffffff;line-height:1.8;overflow-y:auto;}');

./point/point.js 117     return pt1.anchorId === pt2.anchorId && pt1.connectTo === pt2.connectTo;

./diagrams/index.js 15 export * from './line';

./diagrams/index.js 31 import { line } from './line';

./diagrams/index.js 55         line: line,

./diagrams/pentagon.js 5     path.lineTo(x + width, y + (height * 2) / 5);

./diagrams/pentagon.js 6     path.lineTo(x + (width * 4) / 5, y + height);

./diagrams/pentagon.js 7     path.lineTo(x + width / 5, y + height);

./diagrams/pentagon.js 8     path.lineTo(x, y + (height * 2) / 5);

./diagrams/pentagon.js 36     pen.anchors = points.map(function (_a, index) {

./diagrams/pentagram.js 43         path.lineTo(-(basey - centery) * Math.sin((Math.PI / 180) * 72 * i) + centerx, (basey - centery) * Math.cos((Math.PI / 180) * 72 * i) + centery);

./diagrams/pentagram.js 44         path.lineTo((lx - centerx) * Math.cos((Math.PI / 180) * 72 * (i + 1)) -

./diagrams/pentagram.js 58     var anchors = [];

./diagrams/pentagram.js 60         anchors.push({

./diagrams/pentagram.js 68     pen.anchors = anchors;

./diagrams/pentagram.js 73     var manualPoints = pen.anchors.filter(function (point) { return point.flag !== 1; });

./diagrams/pentagram.js 75     pen.anchors = (_a = pen.anchors).concat.apply(_a, __spreadArray([], __read(manualPoints), false));

./diagrams/mindNode.js 38     var manualPoints = pen.anchors.filter(function (point) { return point.flag !== 1; });

./diagrams/mindNode.js 40     pen.anchors = (_a = pen.anchors).concat.apply(_a, __spreadArray([], __read(manualPoints), false));

./diagrams/mindNode.js 48     var anchors = [];

./diagrams/mindNode.js 67         anchors.push({

./diagrams/mindNode.js 68             id: String(anchors.length),

./diagrams/mindNode.js 88         anchors.push({

./diagrams/mindNode.js 89             id: String(anchors.length),

./diagrams/mindNode.js 112         anchors.push({

./diagrams/mindNode.js 113             id: String(anchors.length),

./diagrams/mindNode.js 133         anchors.push({

./diagrams/mindNode.js 134             id: String(anchors.length),

./diagrams/mindNode.js 141     pen.anchors = anchors;

./diagrams/file.js 6     path.lineTo(ex - offsetX, y);

./diagrams/file.js 7     path.lineTo(ex, y + offsetX);

./diagrams/file.js 8     path.lineTo(ex, ey);

./diagrams/file.js 9     path.lineTo(x, ey);

./diagrams/file.js 12     path.lineTo(ex - offsetX, y + offsetX);

./diagrams/file.js 13     path.lineTo(ex, y + offsetX);

./diagrams/triangle.js 5     path.lineTo(x + width, y + height);

./diagrams/triangle.js 6     path.lineTo(x, y + height);

./diagrams/triangle.js 7     path.lineTo(x + width * 2, y);

./diagrams/triangle.js 31     pen.anchors = points.map(function (_a, index) {

./diagrams/cube.js 59             ctx.lineTo(points[i].x, points[i].y);

./diagrams/mindLine.js 5     path.lineTo(x + width, y + height);

./diagrams/mindLine.js 21     pen.anchors = points.map(function (_a, index) {

./diagrams/arrow.js 5     path.lineTo(x + height / 2, y);

./diagrams/arrow.js 6     path.lineTo(x + height / 2, y + height / 3);

./diagrams/arrow.js 7     path.lineTo(x + width, y + height / 3);

./diagrams/arrow.js 8     path.lineTo(x + width, y + (height * 2) / 3);

./diagrams/arrow.js 9     path.lineTo(x + height / 2, y + (height * 2) / 3);

./diagrams/arrow.js 10     path.lineTo(x + height / 2, y + (height * 2) / 3);

./diagrams/arrow.js 11     path.lineTo(x + height / 2, y + height);

./diagrams/arrow.js 20     path.lineTo(x + (width - height / 2), y + height / 3);

./diagrams/arrow.js 21     path.lineTo(x + (width - height / 2), y);

./diagrams/arrow.js 22     path.lineTo(x + width, y + height / 2);

./diagrams/arrow.js 23     path.lineTo(x + (width - height / 2), y + height);

./diagrams/arrow.js 24     path.lineTo(x + (width - height / 2), y + (height * 2) / 3);

./diagrams/arrow.js 25     path.lineTo(x, y + (height * 2) / 3);

./diagrams/arrow.js 34     path.lineTo(x + height / 2, y);

./diagrams/arrow.js 35     path.lineTo(x + height / 2, y + height / 3);

./diagrams/arrow.js 36     path.lineTo(x + (width - height / 2), y + height / 3);

./diagrams/arrow.js 37     path.lineTo(x + (width - height / 2), y);

./diagrams/arrow.js 38     path.lineTo(x + width, y + height / 2);

./diagrams/arrow.js 39     path.lineTo(x + (width - height / 2), y + height);

./diagrams/arrow.js 40     path.lineTo(x + (width - height / 2), y + (height * 2) / 3);

./diagrams/arrow.js 41     path.lineTo(x + height / 2, y + (height * 2) / 3);

./diagrams/arrow.js 42     path.lineTo(x + height / 2, y + height);

./diagrams/diamond.js 5     path.lineTo(x + width, y + height / 2);

./diagrams/diamond.js 6     path.lineTo(x + width / 2, y + height);

./diagrams/diamond.js 7     path.lineTo(x, y + height / 2);

./diagrams/diamond.js 8     path.lineTo(x + width / 2, y);

./diagrams/video.js 18         progress_1.style.outline = 'none';

./diagrams/video.js 44         media_1.style.outline = 'none';

./diagrams/message.js 5     path.lineTo(x + width, y);

./diagrams/message.js 6     path.lineTo(x + width, y + (height * 3) / 4);

./diagrams/message.js 7     path.lineTo(x + (width * 8) / 16, y + (height * 3) / 4);

./diagrams/message.js 8     path.lineTo(x + width / 4, ey);

./diagrams/message.js 9     path.lineTo(x + (width * 5) / 16, y + (height * 3) / 4);

./diagrams/message.js 10     path.lineTo(x, y + (height * 3) / 4);

./diagrams/people.js 8     path.lineTo(ex, y + r * 3);

./diagrams/people.js 10     path.lineTo(middle, y + r * 4);

./diagrams/people.js 12     path.lineTo(x, ey);

./diagrams/people.js 14     path.lineTo(ex, ey);

./diagrams/hexagon.js 5     path.lineTo(x + (width * 3) / 4, y);

./diagrams/hexagon.js 6     path.lineTo(x + width, y + height / 2);

./diagrams/hexagon.js 7     path.lineTo(x + (width * 3) / 4, y + height);

./diagrams/hexagon.js 8     path.lineTo(x + (width * 1) / 4, y + height);

./diagrams/hexagon.js 9     path.lineTo(x, y + height / 2);

./diagrams/hexagon.js 10     path.lineTo(x + width / 4, y);

./diagrams/hexagon.js 16 //   const anchors: Point[] = [];

./diagrams/hexagon.js 17 //   anchors.push({

./diagrams/hexagon.js 23 //   anchors.push({

./diagrams/hexagon.js 29 //   anchors.push({

./diagrams/hexagon.js 35 //   anchors.push({

./diagrams/hexagon.js 41 //   anchors.push({

./diagrams/hexagon.js 47 //   anchors.push({

./diagrams/hexagon.js 53 //   pen.anchors = anchors;

./diagrams/line/curve.jsbak 16 export function curve(store, pen, mousedwon) {

./diagrams/line/curve.jsbak 139     var anchor;

./diagrams/line/curve.jsbak 150         anchor = lerp(p7, p8, t);

./diagrams/line/curve.jsbak 152         anchor.prev = p7;

./diagrams/line/curve.jsbak 154         anchor.next = p8;

./diagrams/line/curve.jsbak 166         anchor = pt;

./diagrams/line/curve.jsbak 169         anchor.prev = p3;

./diagrams/line/curve.jsbak 170         anchor.next = p4;

./diagrams/line/curve.jsbak 176         anchor = pt;

./diagrams/line/curve.jsbak 178     anchor.penId = pen.id;

./diagrams/line/curve.jsbak 179     anchor.id = s8();

./diagrams/line/curve.jsbak 180     anchor.prevNextType = PrevNextType.Bilateral;

./diagrams/line/curve.jsbak 181     return anchor;

./diagrams/line/curve.jsbak 233 //# sourceMappingURL=curve.js.map
./diagrams/line/index.js 1 export * from './line';

./diagrams/line/index.js 2 export * from './curve';

./diagrams/line/index.js 3 export * from './polyline';

./diagrams/line/index.js.map 1 {"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../packages/core/src/diagrams/line/index.ts"],"names":[],"mappings":"AAAA,cAAc,QAAQ,CAAC;AACvB,cAAc,SAAS,CAAC;AACxB,cAAc,YAAY,CAAC;AAC3B,cAAc,UAAU,CAAC"}
./diagrams/line/curve.js 16 export function curve(store, pen, mousedwon) {

./diagrams/line/curve.js 139     var anchor;

./diagrams/line/curve.js 150         anchor = lerp(p7, p8, t);

./diagrams/line/curve.js 152         anchor.prev = p7;

./diagrams/line/curve.js 154         anchor.next = p8;

./diagrams/line/curve.js 166         anchor = pt;

./diagrams/line/curve.js 169         anchor.prev = p3;

./diagrams/line/curve.js 170         anchor.next = p4;

./diagrams/line/curve.js 176         anchor = pt;

./diagrams/line/curve.js 178     anchor.penId = pen.id;

./diagrams/line/curve.js 179     anchor.id = s8();

./diagrams/line/curve.js 180     anchor.prevNextType = PrevNextType.Bilateral;

./diagrams/line/curve.js 181     return anchor;

./diagrams/line/curve.js 233 //# sourceMappingURL=curve.js.map
./diagrams/line/smooth.js 99     // adds bezier control points at points if lines have angle less than thres

./diagrams/line/smooth.js 135                 // bend it if angle between lines is small

./diagrams/line/smooth.js 140                 // use the two normalized vectors along the lines to create the tangent vector

./diagrams/line/polyline.js 30 export function polyline(store, pen, mousedwon) {

./diagrams/line/polyline.js 45     if (((_a = pen.anchors) === null || _a === void 0 ? void 0 : _a.length) && from === pen.calculative.activeAnchor) {

./diagrams/line/polyline.js 50     else if ((!pen.anchors || !pen.anchors.length) &&

./diagrams/line/polyline.js 93     pts.forEach(function (anchor) {

./diagrams/line/polyline.js 94         anchor.id = s8();

./diagrams/line/polyline.js 95         anchor.penId = pen.id;

./diagrams/line/polyline.js 96         pen.calculative.worldAnchors.push(anchor);

./diagrams/line/polyline.js 379     if (pen.calculative.drawlineH == undefined) {

./diagrams/line/polyline.js 380         pen.calculative.drawlineH =

./diagrams/line/polyline.js 385         if (pen.calculative.drawlineH) {

./diagrams/line/polyline.js 400 export function anchorInHorizontal(pen, anchor, from) {

./diagrams/line/polyline.js 403     var anchors = pen.calculative.worldAnchors;

./diagrams/line/polyline.js 405         anchors = [];

./diagrams/line/polyline.js 407             anchors.unshift(item);

./diagrams/line/polyline.js 410     for (var i = 0; i < anchors.length; i++) {

./diagrams/line/polyline.js 411         if (anchors[i].id === anchor.id) {

./diagrams/line/polyline.js 414         if (anchors[i].y !== anchor.y) {

./diagrams/line/polyline.js 417         if (anchors[i].x === ((_a = anchors[i + 1]) === null || _a === void 0 ? void 0 : _a.x) &&

./diagrams/line/polyline.js 418             anchors[i].y !== ((_b = anchors[i + 1]) === null || _b === void 0 ? void 0 : _b.y)) {

./diagrams/line/polyline.js 424 export function anchorInVertical(pen, anchor, from) {

./diagrams/line/polyline.js 427     var anchors = pen.calculative.worldAnchors;

./diagrams/line/polyline.js 429         anchors = [];

./diagrams/line/polyline.js 431             anchors.unshift(item);

./diagrams/line/polyline.js 434     for (var i = 0; i < anchors.length; i++) {

./diagrams/line/polyline.js 435         if (anchors[i].id === anchor.id) {

./diagrams/line/polyline.js 438         if (anchors[i].x !== anchor.x) {

./diagrams/line/polyline.js 441         if (anchors[i].y === ((_a = anchors[i + 1]) === null || _a === void 0 ? void 0 : _a.y) &&

./diagrams/line/polyline.js 442             anchors[i].x !== ((_b = anchors[i + 1]) === null || _b === void 0 ? void 0 : _b.x)) {

./diagrams/line/polyline.js 448 export function translatePolylineAnchor(pen, anchor, pt) {

./diagrams/line/polyline.js 452     var i = pen.calculative.worldAnchors.findIndex(function (item) { return item.id === anchor.id; });

./diagrams/line/polyline.js 459             if (anchorInHorizontal(pen, anchor, true)) {

./diagrams/line/polyline.js 462             else if (anchorInVertical(pen, anchor, true)) {

./diagrams/line/polyline.js 467             if (anchorInHorizontal(pen, anchor, false)) {

./diagrams/line/polyline.js 470             else if (anchorInVertical(pen, anchor, false)) {

./diagrams/line/polyline.js 476                 pen.calculative.h = prev.y === anchor.y;

./diagrams/line/polyline.js 479                 pen.calculative.h = next.y === anchor.y;

./diagrams/line/polyline.js 485         anchor.x = pt.x;

./diagrams/line/polyline.js 486         if (from.connectTo && anchorInHorizontal(pen, anchor, true)) {

./diagrams/line/polyline.js 487             if (next && next.y !== anchor.y) {

./diagrams/line/polyline.js 488                 next.x = anchor.x;

./diagrams/line/polyline.js 492         if (to.connectTo && anchorInHorizontal(pen, anchor, false)) {

./diagrams/line/polyline.js 493             if (prev && prev.y !== anchor.y) {

./diagrams/line/polyline.js 494                 prev.x = anchor.x;

./diagrams/line/polyline.js 498         var a = pen.anchors[i];

./diagrams/line/polyline.js 501             prev = pen.anchors[pos];

./diagrams/line/polyline.js 524             next = pen.anchors[pos];

./diagrams/line/polyline.js 550         anchor.y = pt.y;

./diagrams/line/polyline.js 554         anchor.y = pt.y;

./diagrams/line/polyline.js 555         if (from.connectTo && anchorInVertical(pen, anchor, true)) {

./diagrams/line/polyline.js 556             if (next && next.x !== anchor.x) {

./diagrams/line/polyline.js 557                 next.y = anchor.y;

./diagrams/line/polyline.js 561         if (to.connectTo && anchorInVertical(pen, anchor, false)) {

./diagrams/line/polyline.js 562             if (prev && prev.x !== anchor.x) {

./diagrams/line/polyline.js 563                 prev.y = anchor.y;

./diagrams/line/polyline.js 567         var a = pen.anchors[i];

./diagrams/line/polyline.js 570             prev = pen.anchors[pos];

./diagrams/line/polyline.js 593             next = pen.anchors[pos];

./diagrams/line/polyline.js 619         anchor.x = pt.x;

./diagrams/line/polyline.js 622 //# sourceMappingURL=polyline.js.map
./diagrams/line/line.js 40 import { getBezierPoint, getQuadraticPoint } from './curve';

./diagrams/line/line.js 41 export function line(pen, ctx) {

./diagrams/line/line.js 62 export function lineSegment(store, pen, mousedwon) {

./diagrams/line/line.js 67     if (pen.calculative.worldAnchors.length < 2 || ((_a = pen.anchors) === null || _a === void 0 ? void 0 : _a.length) > 1) {

./diagrams/line/line.js 98             path.lineTo(to.x, to.y);

./diagrams/line/line.js 123     return (pen === null || pen === void 0 ? void 0 : pen.lineWidth) ? pen.lineWidth / 2 + 4 : 4;

./diagrams/line/line.js 131     if (from.lineLength) {

./diagrams/line/line.js 133         step = r / from.lineLength;

./diagrams/line/line.js 158         from.curvePoints = pts;

./diagrams/line/line.js 170             var anchor = _c.value;

./diagrams/line/line.js 172                 point = pointInLineSegment(pt, from, anchor, r);

./diagrams/line/line.js 181             from = anchor;

./diagrams/line/line.js 218     else if (pt1.curvePoints) {

./diagrams/line/line.js 220             for (var _b = __values(pt1.curvePoints), _c = _b.next(); !_c.done; _c = _b.next()) {

./diagrams/line/line.js 262 function lineLen(from, cp1, cp2, to) {

./diagrams/line/line.js 287             from.lineLength = lineLen(from, from.next, pt.prev, pt);

./diagrams/line/line.js 288             len += from.lineLength;

./diagrams/line/line.js 295         from.lineLength = lineLen(from, from.next, to.prev, to);

./diagrams/line/line.js 296         len += from.lineLength;

./diagrams/line/line.js 304 export function lineInRect(line, rect) {

./diagrams/line/line.js 306     var worldAnchors = line.calculative.worldAnchors;

./diagrams/line/line.js 334     var linePointX1 = pt1.x;

./diagrams/line/line.js 335     var linePointY1 = pt1.y;

./diagrams/line/line.js 336     var linePointX2 = pt2.x;

./diagrams/line/line.js 337     var linePointY2 = pt2.y;

./diagrams/line/line.js 342     var lineHeight = linePointY1 - linePointY2;

./diagrams/line/line.js 343     var lineWidth = linePointX2 - linePointX1; // 计算叉乘

./diagrams/line/line.js 344     var c = linePointX1 * linePointY2 - linePointX2 * linePointY1;

./diagrams/line/line.js 345     if ((lineHeight * rectangleLeftTopX + lineWidth * rectangleLeftTopY + c >= 0 &&

./diagrams/line/line.js 346         lineHeight * rectangleRightBottomX +

./diagrams/line/line.js 347             lineWidth * rectangleRightBottomY +

./diagrams/line/line.js 350         (lineHeight * rectangleLeftTopX + lineWidth * rectangleLeftTopY + c <= 0 &&

./diagrams/line/line.js 351             lineHeight * rectangleRightBottomX +

./diagrams/line/line.js 352                 lineWidth * rectangleRightBottomY +

./diagrams/line/line.js 355         (lineHeight * rectangleLeftTopX + lineWidth * rectangleRightBottomY + c >=

./diagrams/line/line.js 357             lineHeight * rectangleRightBottomX + lineWidth * rectangleLeftTopY + c <=

./diagrams/line/line.js 359         (lineHeight * rectangleLeftTopX + lineWidth * rectangleRightBottomY + c <=

./diagrams/line/line.js 361             lineHeight * rectangleRightBottomX + lineWidth * rectangleLeftTopY + c >=

./diagrams/line/line.js 373         if ((linePointX1 < rectangleLeftTopX && linePointX2 < rectangleLeftTopX) ||

./diagrams/line/line.js 374             (linePointX1 > rectangleRightBottomX &&

./diagrams/line/line.js 375                 linePointX2 > rectangleRightBottomX) ||

./diagrams/line/line.js 376             (linePointY1 > rectangleLeftTopY && linePointY2 > rectangleLeftTopY) ||

./diagrams/line/line.js 377             (linePointY1 < rectangleRightBottomY &&

./diagrams/line/line.js 378                 linePointY2 < rectangleRightBottomY)) {

./diagrams/line/line.js 419 //# sourceMappingURL=line.js.map
